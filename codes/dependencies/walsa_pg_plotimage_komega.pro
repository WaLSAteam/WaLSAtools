;+
; NAME:
;
;   pg_plotimage_komega
;
; PURPOSE:
;
;  Plots an image with coordinates pretty much the same way one would use the
;  plot command
;
; CATEGorY:
;
; image display utils
;
; CALLING SEQUENCE:
;
; pg_plotimage,im,x,y [,optional inputs see below]
;
; INPUTS:
;
; im: an n-by-m array
;  x: an n-element array (if not given, [1,2,...,n] is used)
;  y: an m-element array (if not given, [1,2,...,m] is used)
;
; OPTIONAL INPUTS:
;
; addcmd: set to add this command to a currently open resizeable cgWindow
; axiscolor: set to the name of the axis color
; background: set to the name of the background color
; fulledges: set this keyword to have fully sized pixels at the edge of the
; images. It will still look funny in log-scale however.
; psresolution: ps resolution in dpi (default 150)
; no_rescale: use tv instead than tvscl to plot the image
; title: the plot main title
; position: plot position
; window: set to use the resizeable graphics window cgWindow to display this command
; all the graphical optional ketwords starting with x- and y-
;
;
; OUTPUTS:
;
; NOne
;
; COMMON BLOCKS:
;
; NOne
;
; SIDE EFFECTS:
;
; a plot is generated to the current graphics device
;
; RESTRICTIONS:
;
; only tested on X and PS devices, should work with WIN, not sure about Z-buffer though
;
; PROCEDURE:
;
; Every pixel of the final image (to be plotted) is generated by interpolating
; the original dataset at the coordinates of the pixel to be displayed. 
;
; EXAMPLE:
;
;  loadct,5
;  im=dist(128,128)
;  x=findgen(128)
;  y=findgen(128)
;  pg_plotimage,im,x,y,xrange=[5,100],yrange=[5,100],/xstyle,/ystyle,/xlog
;
;
; AUTHor:
; Paolo Grigis, SAO, pgrigis@cfa.harvard.edu
;
; MODifICATION HISTorY:
;
; 25-FEB-2008 written PG
; 26-FEB-2008 made x and y optional PG
; 31-MAR-2008 added /isotropic PG
; 02-APR-2008 fixed bug of /isotropic PG
; 16-JAN-2008 added /fulledges option to have full 
;             sized edge pixels as requested by Brian Larsen on the IDL newsgroup
;             (it's actually a good idea, but didn't make it the default to
;             avoid breaking backwards compatibility) PG
; 18-MAY-2011 turned into a Coyote Graphic command DWF
; May-2020 Slightly modified by Shahin Jafarzadeh
;-

PRO walsa_pg_plotimage_komega,im,x,y,isotropic=isotropic,fulledges=fulledges,_extra=_extra $
                ,xrange=xrange,yrange=yrange,position=position,title=title $
                ,xstyle=xstyle,ystyle=ystyle,smooth=smooth,xlog=xlog,ylog=ylog $
                ,no_rescale=no_rescale,psresolution=psresolution $
                ,xcharsize=xcharsize,xgridstyle=xgridstyle,xminor=xminor,xthick=xthick $
                ,xtick_get=xtick_get,xtickformat=xtickformat,xtickinterval=xtickinterval $
                ,xticklayout=xticklayout,xticklen=xticklen,xtickname=xtickname,xticks=xticks $
                ,xtickunits=xtickunits,xtickv=xtickv,xtitle=xtitle, eps=eps $
                ,ycharsize=ycharsize,ygridstyle=ygridstyle,yminor=yminor,ythick=ythick $
                ,ytick_get=ytick_get,ytickformat=ytickformat,ytickinterval=ytickinterval $
                ,yticklayout=yticklayout,yticklen=yticklen,ytickname=ytickname,yticks=yticks $
                ,ytickunits=ytickunits,ytickv=ytickv,ytitle=ytitle,noerase=noerase, threemin=threemin, fivemin=fivemin $
                ,axiscolor=axiscolor, background=background, layout=layout, window=window, addcmd=addcmd, $
                noy2=noy2, nox2=nox2


    Compile_Opt idl2

    Catch, theError
    if theError ne 0 then begin
        Catch, /CANCEL
        void = Error_Message()
        if N_Elements(thisMulti) ne 0 then !P.Multi = thisMulti
        if N_Elements(currentState) ne 0 then SetDecomposedState, currentState
        return
    endif
    
    ; Set up PostScript device for working with colors.
    if !D.Name EQ 'PS' then Device, COLor=1, BITS_PER_PIXEL=8
    
    ; Check parameters.
    if N_Params() EQ 0 then begin
        Print, 'USE SYNTAX: walsa_pg_plotimage, im, x, y'
        return
    endif
    
    ; Pay attention to !P.Noerase in setting the NOERASE kewyord. This must be
    ; done BEForE checking the LAYOUT properties.
    if !P.NoErase ne 0 then noerase = !P.NoErase else noerase = Keyword_Set(noerase)
    
    ; Do they want this plot in a resizeable graphics window?
    if Keyword_Set(addcmd) then window = 1
    
    if EPS eq 1 then window = 0
    
    if Keyword_Set(window) and ((!D.Flags and 256) ne 0) then begin
            
        ; Special treatment for overplotting or adding a command.
        if Keyword_Set(overplot) or Keyword_Set(addcmd) then begin
        cgWindow, 'walsa_pg_plotimage', im, x, y, isotropic=isotropic,fulledges=fulledges,_extra=_extra $
                ,xrange=xrange,yrange=yrange,position=position,title=title $
                ,xstyle=xstyle,ystyle=ystyle,smooth=smooth,xlog=xlog,ylog=ylog $
                ,no_rescale=no_rescale,psresolution=psresolution $
                ,xcharsize=xcharsize,xgridstyle=xgridstyle,xminor=xminor,xthick=xthick $
                ,xtick_get=xtick_get,xtickformat=xtickformat,xtickinterval=xtickinterval $
                ,xticklayout=xticklayout,xticklen=xticklen,xtickname=xtickname,xticks=xticks $
                ,xtickunits=xtickunits,xtickv=xtickv,xtitle=xtitle $
                ,ycharsize=ycharsize,ygridstyle=ygridstyle,yminor=yminor,ythick=ythick $
                ,ytick_get=ytick_get,ytickformat=ytickformat,ytickinterval=ytickinterval $
                ,yticklayout=yticklayout,yticklen=yticklen,ytickname=ytickname,yticks=yticks $
                ,ytickunits=ytickunits,ytickv=ytickv,ytitle=ytitle,noerase=noerase $
                ,axiscolor=axiscolor, background=background, layout=layout, addcmd=1
             return
        endif
        
        ; Open a new window or replace the current commands, as required.
        currentWindow = cgQuery(/CURRENT, COUNT=wincnt)
        if wincnt EQ 0 then replaceCmd = 0 else replaceCmd=1
        cgWindow, 'walsa_pg_plotimage', im, x, y, isotropic=isotropic,fulledges=fulledges,_extra=_extra $
                ,xrange=xrange,yrange=yrange,position=position,title=title $
                ,xstyle=xstyle,ystyle=ystyle,smooth=smooth,xlog=xlog,ylog=ylog $
                ,no_rescale=no_rescale,psresolution=psresolution $
                ,xcharsize=xcharsize,xgridstyle=xgridstyle,xminor=xminor,xthick=xthick $
                ,xtick_get=xtick_get,xtickformat=xtickformat,xtickinterval=xtickinterval $
                ,xticklayout=xticklayout,xticklen=xticklen,xtickname=xtickname,xticks=xticks $
                ,xtickunits=xtickunits,xtickv=xtickv,xtitle=xtitle $
                ,ycharsize=ycharsize,ygridstyle=ygridstyle,yminor=yminor,ythick=ythick $
                ,ytick_get=ytick_get,ytickformat=ytickformat,ytickinterval=ytickinterval $
                ,yticklayout=yticklayout,yticklen=yticklen,ytickname=ytickname,yticks=yticks $
                ,ytickunits=ytickunits,ytickv=ytickv,ytitle=ytitle,noerase=noerase $
                ,axiscolor=axiscolor, background=background, layout=layout, replaceCmd=replaceCmd            
         return
    endif
    
    ; Get the current color table vectors.
    TVLCT, rr, gg, bb, /GET
    
    ; Going to do this in decomposed color, if possible.
    SetDecomposedState, 1, CURRENTSTATE=currentState
    
    ; Set up the layout, if necessary.
    if N_Elements(layout) ne 0 then begin
       thisMulti = !P.Multi
       totalPlots = layout[0]*layout[1]
       !P.Multi = [0,layout[0], layout[1], 0, 0]
       if layout[2] EQ 1 then begin
            noerase = 1
            !P.Multi[0] = 0
       endif else begin
            !P.Multi[0] = totalPlots - layout[2] + 1
       endelse
    endif

  nx=n_elements(x)
  ny=n_elements(y)


  s=size(im)
  if s[0] ne 2 then Message, 'Only 2D images are allowed.
  if nx EQ 0 then x=findgen(s[1])+1
  if ny EQ 0 then y=findgen(s[2])+1
  if n_elements(background) EQ 0 then background = 'white'  
  if n_elements(axiscolor) EQ 0 then axiscolor = 'opposite'
  
  
  if n_elements(xrange) ne 2 then begin 
     if keyword_set(fulledges) then begin 
        xrange=[min(x)-(x[1]-x[0])*0.5,max(x)+(x[nx-1]-x[nx-2])*0.5] 
     endif $ 
     else begin 
        xrange=[min(x),max(x)]
     endelse 
  endif

  if n_elements(yrange) ne 2 then begin 
     if keyword_set(fulledges) then begin 
        yrange=[min(y)-(y[1]-y[0])*0.5,max(y)+(y[ny-1]-y[ny-2])*0.5] 
     endif $
     else begin 
        yrange=[min(y),max(y)] 
     endelse 
  endif

  if n_elements(xrange) EQ 2 and xrange[0] EQ 0 then begin 
     if keyword_set(fulledges) then begin 
        xrange=[min(x)-(x[1]-x[0])*0.5,max(x)+(x[nx-1]-x[nx-2])*0.5] 
     endif $ 
     else begin 
        xrange=[min(x),xrange[1]]
     endelse 
  endif

  if n_elements(yrange) EQ 2 and yrange[0] EQ 0 then begin 
     if keyword_set(fulledges) then begin 
        yrange=[min(y)-(y[1]-y[0])*0.5,max(y)+(y[ny-1]-y[ny-2])*0.5] 
     endif $
     else begin 
        yrange=[min(y),yrange[1]] 
     endelse 
  endif

;  if (n_elements(position) ne 4) and !P.multi[1] EQ 0 then position=[0.1,0.1,0.9,0.9]
  if n_elements(xlog) ne 1 then xlog=0
  if n_elements(ylog) ne 1 then ylog=0
  

  ;establish plot coordinates, draw axis
  cgplot,[0,0],xrange=xrange,yrange=yrange,position=position,title=title $
            ,xstyle=xstyle,ystyle=ystyle,xlog=xlog,ylog=ylog,/nodata,isotropic=isotropic $
            ,xcharsize=xcharsize,xgridstyle=xgridstyle,xminor=xminor,xthick=xthick $
            ,xtick_get=xtick_get,xtickformat=xtickformat,xtickinterval=xtickinterval $
            ,xticklayout=xticklayout,xticklen=xticklen,xtickname=xtickname,xticks=xticks $
            ,xtickunits=xtickunits,xtickv=xtickv,xtitle=xtitle $
            ,ycharsize=ycharsize,ygridstyle=ygridstyle,yminor=yminor,ythick=ythick $
            ,ytick_get=ytick_get,ytickformat=ytickformat,ytickinterval=ytickinterval $
            ,yticklayout=yticklayout,yticklen=yticklen,ytickname=ytickname,yticks=yticks $
            ,ytickunits=ytickunits,ytickv=ytickv,ytitle=ytitle,noerase=noerase,_extra=_extra $
            ,color=axiscolor, background=background

  ;get pixel size of window
  xsize=!D.x_size
  ysize=!D.y_size

  position=[!X.window[0],!Y.window[0],!X.window[1],!Y.window[1]]

  if !D.name EQ 'PS' then begin 
     if n_elements(psresolution) ne 1 then psresolution=150
     xsize=xsize/(2.54*!D.x_px_cm)*psresolution
     ysize=ysize/(2.54*!D.y_px_cm)*psresolution
  endif



  ;compute pixel size of plot area
  dxpix=round((position[2]-position[0])*xsize)
  dypix=round((position[3]-position[1])*ysize)


  ;compute coordinates in data space for the all the *pixels* of the image to be displayed
  ;in both linear and log scale
  if xlog EQ 1 then begin 
     nxpix=10^(!x.crange[0]+findgen(dxpix)/(dxpix-1.)*(!X.crange[1]-!X.crange[0]))
  endif $
  else begin 
     nxpix=!x.crange[0]+findgen(dxpix)/(dxpix-1.)*(!X.crange[1]-!X.crange[0])
  endelse 

  if ylog EQ 1 then begin
     nypix=10^(!y.crange[0]+findgen(dypix)/(dypix-1.)*(!Y.crange[1]-!Y.crange[0]))
  endif $
  else begin 
     nypix=!y.crange[0]+findgen(dypix)/(dypix-1.)*(!Y.crange[1]-!Y.crange[0])
  endelse 


  ;axis range in data coordinates
  actualxrange=xlog EQ 0 ? !x.crange : 10.^!x.crange
  actualyrange=ylog EQ 0 ? !y.crange : 10.^!y.crange

  
  ;we have two coordinates, x,y and npix,npiy
  ;but we only need to apply the interpolation in the intersection
  ;between x and xrange, and y and yrange

  ;if the bottom, top, right, left lines muct be
  ;one pixel size (instead of half)
  if keyword_set(fulledges) then begin 

  
     neededcoordindx=where(nxpix GE min(x)-(x[1]-x[0])*0.5 and nxpix LE max(x)+(x[nx-1]-x[nx-2])*0.5,countx)
     neededcoordindy=where(nypix GE min(y)-(y[1]-y[0])*0.5 and nypix LE max(y)+(y[ny-1]-y[ny-2])*0.5,county)

  endif $
  else begin 
     ;pixels coordinates only between min(x) and max(x), min(y) and max(y)
     neededcoordindx=where(nxpix GE min(x) and nxpix LE max(x),countx)
     neededcoordindy=where(nypix GE min(y) and nypix LE max(y),county)
  endelse


  ;original image pixels only in xrange and yrange
  neededindx=where(x GE actualxrange[0] and x LE actualxrange[1],countx2)
  neededindy=where(y GE actualyrange[0] and y LE actualyrange[1],county2)
  
  if (countx EQ 0) or (county EQ 0) then return
  if (countx2 EQ 0) or (county2 EQ 0) then return


  ;interpolates the coordinates to get back to index space for the new image
  xint=interpol(findgen(countx2),x[neededindx],nxpix[neededcoordindx])
  yint=interpol(findgen(county2),y[neededindy],nypix[neededcoordindy])

  ;this makes blocky pixels if interpolation is not wanted
  if NOT keyword_set(smooth) then begin 
     xint=round(xint)
     yint=round(yint)
  endif

  ;interpolate the original image to get the new image to display
  ;the new image size is given by the pixel in the plot area
  newimage=interpolate(im[min(neededindx):max(neededindx),min(neededindy):max(neededindy)],xint,yint,/grid) 
 
  if keyword_set(fulledges) then begin 

                                ;get coordinates of lower left & upper right pixel in normalized coordinates
     normcoordllc=convert_coord(max([min(x)-(x[1]-x[0])*0.5,actualxrange[0]]),max([min(y)-(y[1]-y[0])*0.5,actualyrange[0]]),/data,/to_norm)
     normcoordurc=convert_coord(min([max(x)+(x[nx-1]-x[nx-2])*0.5,actualxrange[1]]),min([max(y)+(y[ny-1]-y[ny-2])*0.5,actualyrange[1]]),/data,/to_norm)

  endif $
  else begin 
                                ;get coordinates of lower left & upper right pixel in normalized coordinates
     normcoordllc=convert_coord(max([min(x),actualxrange[0]]),max([min(y),actualyrange[0]]),/data,/to_norm)
     normcoordurc=convert_coord(min([max(x),actualxrange[1]]),min([max(y),actualyrange[1]]),/data,/to_norm)
    
  endelse 

  ;plot image on the screen, rescaling depends on the value of rescale kyword
  ;xsize,ysize needed for PS output only
  SetDecomposedState, 0, CURRENT=current
  if keyword_set(no_rescale) then $
     tv,newimage,normcoordllc[0],normcoordllc[1],/normal $
       ,xsize=normcoordurc[0]-normcoordllc[0],ysize=normcoordurc[1]-normcoordllc[1] $
  else $     
     tvscl,newimage,normcoordllc[0],normcoordllc[1],/normal $
          ,xsize=normcoordurc[0]-normcoordllc[0],ysize=normcoordurc[1]-normcoordllc[1]
  SetDecomposedState, current

  ;replot the x- and y- axis, as they may have been overwritten by the image
  ;most of the stuff is just keyword propagation
  if xlog EQ 1 then begin
      if nox2 eq 0 then cgAxis, XAxis=1, XRange=[2.*!pi/xrange[0],2.*!pi/xrange[1]], xticklen=xticklen, $
         xstyle=1, /xlog, title='Spatial size (arcsec)!C',xminor=xminor,xthick=xthick, $
         xtickformat=xtickformat,xtickinterval=xtickinterval,xticks=(n_elements(LogLevels([2.*!pi/xrange[0],2.*!pi/xrange[1]])))-1, $
         xcharsize=xcharsize, XTICKV=LogLevels([2.*!pi/xrange[0],2.*!pi/xrange[1]]) ; added by SJ

  endif else begin
     cgaxis,1,!Y.crange[0],xaxis=0,xlog=0,xstyle=1,xrange=xrange,/data $
                ,xcharsize=xcharsize,xgridstyle=xgridstyle,xminor=xminor,xthick=xthick $
                ,xtick_get=xtick_get,xtickformat=xtickformat,xtickinterval=xtickinterval $
                ,xticklayout=xticklayout,xticklen=xticklen,xtickname=xtickname,xticks=xticks $
                ,xtickunits=xtickunits,xtickv=xtickv,xtitle=xtitle, color=axiscolor

     if nox2 eq 0 then cgaxis,XAxis=1, XRange=xrange, xticklen=xticklen, $
         xstyle=1, xlog=0, title='Spatial size (arcsec)!C',xthick=xthick, xcharsize=xcharsize, $
         XTICKNAME = string(2.*!pi/xtick_get,format='(F0.1)') ; added by SJ

  endelse

  if ylog EQ 1 then begin
      if noy2 eq 0 then cgAxis, YAxis=1, YRange=[1000./yrange[0],1000./yrange[1]], yticklen=yticklen, $
         ystyle=1, /ylog, title='Period (s)',yminor=yminor,ythick=ythick, $
         ytickformat=ytickformat,ytickinterval=ytickinterval,yticks=(n_elements(LogLevels([1000./yrange[0],1000./yrange[1]])))-1, $
         ycharsize=ycharsize, YTICKV=LogLevels([1000./yrange[0],1000./yrange[1]]) ; added by SJ

  endif else begin
     cgaxis,!X.crange[0],1,yaxis=0,ylog=0,ystyle=1,yrange=yrange,/data $
                ,ycharsize=ycharsize,ygridstyle=ygridstyle,yminor=yminor,ythick=ythick $
                ,ytick_get=ytick_get,ytickformat=ytickformat,ytickinterval=ytickinterval $
                ,yticklayout=yticklayout,yticklen=yticklen,ytickname=ytickname,yticks=yticks $
                ,ytickunits=ytickunits,ytickv=ytickv,ytitle=ytitle, color=axiscolor

     if noy2 eq 0 then cgaxis, YAxis=1, YRange=yrange, yticklen=yticklen,  $
         ystyle=1, ylog=0, title='Period (s)',ythick=ythick, ycharsize=ycharsize, $
         YTICKNAME = string(1000./ytick_get,format='(F0.1)') ; added by SJ

  endelse

    ; Restore the decomposed color state if you can.
    SetDecomposedState, currentState
    
    ; Restore the color table. Can't do this for the Z-buffer or
    ; the snap shot will be incorrect.
    if (!D.Name ne 'Z') then TVLCT, rr, gg, bb
    
    ; Clean up if you are using a layout.
    if N_Elements(layout) ne 0 then !P.Multi = thisMulti
    
    if n_elements(threemin) ne 0 then sjhline, 1000/180., color=0, linestyle=2 ; added by SJ
    if n_elements(fivemin) ne 0 then sjhline, 1000/300., color=0, linestyle=2 ; added by SJ
 
end